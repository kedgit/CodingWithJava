			**FileHandling in java**


Here is a hierarchical tree showing the main classes involved in Java I/O streams, divided into:

Byte Streams (InputStream / OutputStream)
Character Streams (Reader / Writer)

java.io
├── InputStream              ← abstract (for reading bytes)
│   ├── FileInputStream
│   ├── ByteArrayInputStream
│   ├── ObjectInputStream
│   └── BufferedInputStream
|
├── OutputStream             ← abstract (for writing bytes)
│   ├── FileOutputStream
│   ├── ByteArrayOutputStream
│   ├── ObjectOutputStream
│   └── BufferedOutputStream
|
├── Reader                   ← abstract (for reading characters)
│   ├── FileReader
│   ├── CharArrayReader
│   ├── StringReader
│   └── BufferedReader
|
├── Writer                   ← abstract (for writing characters)
│   ├── FileWriter
│   ├── CharArrayWriter
│   ├── StringWriter
│   └── BufferedWriter


FileInputStream		Read bytes from a file
FileOutputStream		Write bytes to a file
FileReader			Read characters from a file
FileWriter			Write characters to a file
BufferedReader		Read lines efficiently
BufferedWriter		Write text efficiently

Explanation:

1.Byte Streams:

--> Use InputStream and OutputStream
--> Work with raw binary data (e.g., images, files, videos)

2.Character Streams:

--> Use Reader and Writer
--> Work with text (character) data (e.g., .txt files)

Note:
- When you open a file, the OS gives Java a handle to the file and knows the file size.
- Every time you call read(), Java asks the OS to provide the next byte at the current position.
- The OS tracks the read position internally.
- When the read position reaches the file’s end (i.e., all bytes have been read), the OS signals there is no more data.
- Java’s FileInputStream.read() method then returns -1 to indicate EOF.
